#include <WiFi.h>
#include <WebServer.h>
#include <ArduinoJson.h>
#include <Firebase_ESP_Client.h>
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

// ==================== KONFIGURASI ====================
const char* ssid = "smk unnes semarang";
const char* password = "12345678";

#define FIREBASE_HOST "ecofarm-iot-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH "8PDjRTyCq52JDqwntLZqBFt0Is3odlDzZULmZREJ"

#define NUM_NODES 4

// ==================== FIREBASE OBJECTS ====================
FirebaseData fbdo;
FirebaseData fbdo_stream;
FirebaseAuth auth;
FirebaseConfig config;

WebServer server(8080);

// ==================== STRUKTUR DATA ====================
struct NodeControl {
  bool manual_mode;
  bool actuator_command;  // Unified: pump untuk Node 2, exhaust untuk Node 1
  float setpoint;         // setpoint_ppm untuk Node 2, temp_threshold untuk Node 1
  unsigned long timestamp;
};

struct NodeStatus {
  unsigned long last_seen;
  bool online;
  int node_type;  // 1 = DHT+Exhaust, 2 = TDS+pH
  
  // Type 1 (Exhaust) fields
  float temperature;
  float humidity;
  int exhaust_status;  // 0=OFF, 1=SEDANG, 2=MENYALA
  
  // Type 2 (Nutrisi) fields
  float current_ppm;
  float current_ph;
  bool pump_active;
  
  String mode;
};

NodeControl controls[NUM_NODES];
NodeStatus node_status[NUM_NODES];

// Status Firebase
bool firebaseReady = false;
bool streamReady = false;
unsigned long lastStreamCheck = 0;

// ==================== FUZZY MAMDANI UNTUK NODE SENSOR 1 ====================
// Membership functions untuk INPUT (Suhu)
float membershipSuhuRendah(float temp) {
  if (temp <= 25.0f) return 1.0f;
  if (temp >= 28.0f) return 0.0f;
  return (28.0f - temp) / 3.0f;
}

float membershipSuhuNormal(float temp) {
  if (temp <= 25.0f || temp >= 32.0f) return 0.0f;
  if (temp >= 28.0f && temp <= 30.0f) return 1.0f;
  if (temp < 28.0f) return (temp - 25.0f) / 3.0f;
  return (32.0f - temp) / 2.0f;
}

float membershipSuhuTinggi(float temp) {
  if (temp <= 30.0f) return 0.0f;
  if (temp >= 35.0f) return 1.0f;
  return (temp - 30.0f) / 5.0f;
}

// Membership functions untuk INPUT (Humidity)
float membershipHumidityRendah(float hum) {
  if (hum <= 60.0f) return 1.0f;
  if (hum >= 70.0f) return 0.0f;
  return (70.0f - hum) / 10.0f;
}

float membershipHumidityNormal(float hum) {
  if (hum <= 60.0f || hum >= 85.0f) return 0.0f;
  if (hum >= 70.0f && hum <= 80.0f) return 1.0f;
  if (hum < 70.0f) return (hum - 60.0f) / 10.0f;
  return (85.0f - hum) / 5.0f;
}

float membershipHumidityTinggi(float hum) {
  if (hum <= 80.0f) return 0.0f;
  if (hum >= 90.0f) return 1.0f;
  return (hum - 80.0f) / 10.0f;
}

// Membership functions untuk OUTPUT (Status Exhaust)
// Output: 0 = MATI, 1 = SEDANG, 2 = MENYALA
float defuzzifyExhaust(float mati, float sedang, float menyala) {
  // Centroid defuzzification
  float num = (mati * 0.0f) + (sedang * 1.0f) + (menyala * 2.0f);
  float den = mati + sedang + menyala;
  
  if (den == 0.0f) return 0.0f;
  
  float result = num / den;
  
  // Convert ke integer status
  if (result < 0.5f) return 0.0f;      // MATI
  if (result < 1.5f) return 1.0f;      // SEDANG
  return 2.0f;                          // MENYALA
}

// Struktur untuk menyimpan hasil fuzzy lengkap
struct FuzzyResult {
  float mu_temp_low;
  float mu_temp_normal;
  float mu_temp_high;
  float mu_hum_low;
  float mu_hum_normal;
  float mu_hum_high;
  float out_off;
  float out_medium;
  float out_high;
  float crisp_output;
  int exhaust_status;
};

// FUZZY RULES dengan output lengkap
FuzzyResult fuzzyControlExhaust(float temperature, float humidity) {
  FuzzyResult result;
  
  // Fuzzifikasi INPUT - TEMPERATURE
  result.mu_temp_low = membershipSuhuRendah(temperature);
  result.mu_temp_normal = membershipSuhuNormal(temperature);
  result.mu_temp_high = membershipSuhuTinggi(temperature);
  
  // Fuzzifikasi INPUT - HUMIDITY
  result.mu_hum_low = membershipHumidityRendah(humidity);
  result.mu_hum_normal = membershipHumidityNormal(humidity);
  result.mu_hum_high = membershipHumidityTinggi(humidity);
  
  // Rule Base (9 Rules menggunakan MIN-MAX)
  // Rule 1: IF Suhu Rendah THEN Exhaust Mati
  float rule1_mati = result.mu_temp_low;
  
  // Rule 2: IF Suhu Normal AND Rendah THEN Exhaust Mati
  float rule2_mati = min(result.mu_temp_normal, result.mu_temp_low);
  
  // Rule 3: IF Suhu Normal THEN Exhaust Sedang
  float rule3_sedang = result.mu_temp_normal;
  
  // Rule 4: IF Suhu Normal AND Tinggi THEN Exhaust Sedang
  float rule4_sedang = min(result.mu_temp_normal, result.mu_temp_high);
  
  // Rule 5: IF Suhu Tinggi AND Normal THEN Exhaust Sedang
  float rule5_sedang = min(result.mu_temp_high, result.mu_temp_normal);
  
  // Rule 6: IF Suhu Tinggi THEN Exhaust Menyala
  float rule6_menyala = result.mu_temp_high;
  
  // Rule 7: IF Suhu Tinggi AND NOT Normal THEN Exhaust Menyala
  float rule7_menyala = min(result.mu_temp_high, 1.0f - result.mu_temp_normal);
  
  // Rule 8: IF Suhu Sangat Tinggi THEN Exhaust Menyala (backup)
  float rule8_menyala = (temperature > 35.0f) ? 1.0f : 0.0f;
  
  // Rule 9: IF Suhu Normal AND NOT Rendah AND NOT Tinggi THEN Exhaust Sedang
  float rule9_sedang = min(result.mu_temp_normal, min(1.0f - result.mu_temp_low, 1.0f - result.mu_temp_high));
  
  // Agregasi OUTPUT (MAX)
  result.out_off = max(rule1_mati, rule2_mati);
  result.out_medium = max(max(rule3_sedang, rule4_sedang), max(rule5_sedang, rule9_sedang));
  result.out_high = max(max(rule6_menyala, rule7_menyala), rule8_menyala);
  
  // Defuzzifikasi (Centroid)
  result.crisp_output = defuzzifyExhaust(result.out_off, result.out_medium, result.out_high);
  result.exhaust_status = (int)result.crisp_output;
  
  Serial.println("\n========== FUZZY COMPUTATION ==========");
  Serial.printf("INPUT -> Temp=%.1f°C, Hum=%.1f%%\n", temperature, humidity);
  Serial.printf("μ_Temp -> Low=%.3f, Normal=%.3f, High=%.3f\n", 
                result.mu_temp_low, result.mu_temp_normal, result.mu_temp_high);
  Serial.printf("μ_Hum  -> Low=%.3f, Normal=%.3f, High=%.3f\n",
                result.mu_hum_low, result.mu_hum_normal, result.mu_hum_high);
  Serial.printf("OUTPUT -> Off=%.3f, Medium=%.3f, High=%.3f\n",
                result.out_off, result.out_medium, result.out_high);
  Serial.printf("CRISP  -> %.3f -> Status=%d\n", result.crisp_output, result.exhaust_status);
  Serial.println("========================================\n");
  
  return result;
}

// ==================== FIREBASE STREAM CALLBACK ====================
void streamCallback(FirebaseStream data) {
  Serial.println("\n========== FIREBASE STREAM UPDATE ==========");
  Serial.printf("Path: %s\n", data.dataPath().c_str());
  
  String path = data.dataPath();
  
  if (path.startsWith("/nodes/node_")) {
    int nodeStart = path.indexOf("node_") + 5;
    int nodeEnd = path.indexOf("/", nodeStart);
    if (nodeEnd == -1) nodeEnd = path.length();
    
    String nodeStr = path.substring(nodeStart, nodeEnd);
    int nodeId = nodeStr.toInt();
    
    if (nodeId >= 1 && nodeId <= NUM_NODES && path.indexOf("/control") != -1) {
      FirebaseJson json = data.jsonObject();
      FirebaseJsonData jsonData;
      
      NodeControl& ctrl = controls[nodeId - 1];
      
      if (json.get(jsonData, "manual_mode")) {
        ctrl.manual_mode = jsonData.boolValue;
      }
      if (json.get(jsonData, "actuator_command")) {
        ctrl.actuator_command = jsonData.boolValue;
      }
      if (json.get(jsonData, "setpoint")) {
        ctrl.setpoint = jsonData.floatValue;
      }
      
      ctrl.timestamp = millis();
      
      Serial.printf("✓ Node %d Updated: Mode=%s, Command=%s, Setpoint=%.1f\n", 
                    nodeId,
                    ctrl.manual_mode ? "MANUAL" : "AUTO",
                    ctrl.actuator_command ? "ON" : "OFF",
                    ctrl.setpoint);
    }
  }
  Serial.println("============================================\n");
}

void streamTimeoutCallback(bool timeout) {
  if (timeout) {
    Serial.println("[STREAM] ⚠ Timeout - will reconnect");
    streamReady = false;
  }
}

// ==================== FIREBASE FUNCTIONS ====================
void setupFirebaseStream() {
  if (!firebaseReady) {
    Serial.println("[FIREBASE] Not ready, skip stream setup");
    return;
  }
  
  Serial.println("[FIREBASE] Setting up real-time stream...");
  
  if (Firebase.RTDB.beginStream(&fbdo_stream, "/nodes")) {
    Firebase.RTDB.setStreamCallback(&fbdo_stream, streamCallback, streamTimeoutCallback);
    streamReady = true;
    Serial.println("[FIREBASE] ✅ Stream active!");
  } else {
    Serial.printf("[FIREBASE] ❌ Stream failed: %s\n", fbdo_stream.errorReason().c_str());
    streamReady = false;
  }
}

void syncControlFromFirebase() {
  if (!firebaseReady) return;
  
  Serial.println("\n[FIREBASE] Syncing control data...");
  
  for (int i = 1; i <= NUM_NODES; i++) {
    String path = "/nodes/node_" + String(i) + "/control";
    
    if (Firebase.RTDB.getJSON(&fbdo, path.c_str())) {
      if (fbdo.dataType() == "json") {
        FirebaseJson json = fbdo.jsonObject();
        FirebaseJsonData jsonData;
        
        NodeControl& ctrl = controls[i - 1];
        
        if (json.get(jsonData, "manual_mode")) {
          ctrl.manual_mode = jsonData.boolValue;
        }
        if (json.get(jsonData, "actuator_command")) {
          ctrl.actuator_command = jsonData.boolValue;
        }
        if (json.get(jsonData, "setpoint")) {
          ctrl.setpoint = jsonData.floatValue;
        }
        
        ctrl.timestamp = millis();
        
        Serial.printf("  ✓ Node %d: Mode=%s, Setpoint=%.1f\n", 
                      i, ctrl.manual_mode ? "MANUAL" : "AUTO", ctrl.setpoint);
      }
    }
    delay(50);
  }
  
  Serial.println("[FIREBASE] Sync complete!\n");
}

bool sendToFirebase(int node_id, const DynamicJsonDocument& sensorDoc) {
  if (!firebaseReady) {
    Serial.println("[FIREBASE] ⚠ Not connected");
    return false;
  }
  
  int idx = node_id - 1;
  node_status[idx].last_seen = millis();
  node_status[idx].online = true;
  
  // Update node status berdasarkan data yang diterima
  if (sensorDoc.containsKey("temperature")) {
    node_status[idx].node_type = 1;
    node_status[idx].temperature = sensorDoc["temperature"];
    node_status[idx].humidity = sensorDoc["humidity"];
    if (sensorDoc.containsKey("exhaust_status")) {
      node_status[idx].exhaust_status = sensorDoc["exhaust_status"];
    }
  } else if (sensorDoc.containsKey("ppm")) {
    node_status[idx].node_type = 2;
    node_status[idx].current_ppm = sensorDoc["ppm"];
    node_status[idx].current_ph = sensorDoc["ph"];
    if (sensorDoc.containsKey("pump_active")) {
      node_status[idx].pump_active = sensorDoc["pump_active"];
    }
  }
  
  if (sensorDoc.containsKey("mode")) {
    node_status[idx].mode = sensorDoc["mode"].as<String>();
  }
  
  String dataPath = "/nodes/node_" + String(node_id) + "/sensor_data";
  String statusPath = "/nodes/node_" + String(node_id) + "/status";
  
  FirebaseJson dataJson;
  dataJson.setJsonData(sensorDoc.as<String>());
  
  bool dataSuccess = Firebase.RTDB.pushJSON(&fbdo, dataPath.c_str(), &dataJson);
  
  if (dataSuccess) {
    FirebaseJson statusJson;
    statusJson.set("online", true);
    statusJson.set("last_seen", millis());
    statusJson.set("node_type", node_status[idx].node_type);
    
    if (node_status[idx].node_type == 1) {
      statusJson.set("temperature", node_status[idx].temperature);
      statusJson.set("humidity", node_status[idx].humidity);
      statusJson.set("exhaust_status", node_status[idx].exhaust_status);
    } else if (node_status[idx].node_type == 2) {
      statusJson.set("current_ppm", node_status[idx].current_ppm);
      statusJson.set("current_ph", node_status[idx].current_ph);
      statusJson.set("pump_active", node_status[idx].pump_active);
    }
    
    statusJson.set("mode", node_status[idx].mode);
    
    Firebase.RTDB.setJSON(&fbdo, statusPath.c_str(), &statusJson);
    
    Serial.printf("[FIREBASE] ✅ Data sent for Node %d\n", node_id);
    return true;
  } else {
    Serial.printf("[FIREBASE] ❌ Failed to send: %s\n", fbdo.errorReason().c_str());
    return false;
  }
}

// ==================== HTTP HANDLERS ====================
void setCORSHeaders() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

void handleOptions() {
  setCORSHeaders();
  server.send(200, "text/plain", "");
}

void handlePing() {
  setCORSHeaders();
  
  DynamicJsonDocument doc(256);
  doc["status"] = "ok";
  doc["gateway"] = "greenhouse-monitoring";
  doc["ip"] = WiFi.localIP().toString();
  doc["uptime"] = millis() / 1000;
  doc["firebase"] = firebaseReady ? "connected" : "disconnected";
  doc["stream"] = streamReady ? "active" : "inactive";
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
  
  Serial.println("[PING] ✓ Received");
}

// UNIFIED Node sync endpoint untuk SEMUA node
void handleNodeSync() {
  setCORSHeaders();
  
  if (server.method() != HTTP_POST) {
    server.send(405, "application/json", "{\"error\":\"Method not allowed\"}");
    return;
  }
  
  String body = server.arg("plain");
  
  Serial.println("\n========== NODE SYNC ==========");
  
  if (body.length() == 0) {
    server.send(400, "application/json", "{\"error\":\"Empty body\"}");
    return;
  }
  
  DynamicJsonDocument doc(1024);
  DeserializationError error = deserializeJson(doc, body);
  
  if (error) {
    Serial.printf("JSON Error: %s\n", error.c_str());
    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
    return;
  }
  
  if (!doc.containsKey("node_id")) {
    server.send(400, "application/json", "{\"error\":\"Missing node_id\"}");
    return;
  }
  
  int node_id = doc["node_id"];
  
  if (node_id < 1 || node_id > NUM_NODES) {
    server.send(400, "application/json", "{\"error\":\"Invalid node_id\"}");
    return;
  }
  
  doc["server_timestamp"] = millis();
  
  int idx = node_id - 1;
  NodeControl& ctrl = controls[idx];
  
  // FUZZY LOGIC UNTUK NODE SENSOR 1 (DHT + Exhaust)
  if (doc.containsKey("temperature") && doc.containsKey("humidity") && !ctrl.manual_mode) {
    float temp = doc["temperature"];
    float hum = doc["humidity"];
    
    // Jalankan fuzzy logic
    FuzzyResult fuzzyResult = fuzzyControlExhaust(temp, hum);
    
    // Update control command berdasarkan fuzzy
    ctrl.actuator_command = (fuzzyResult.exhaust_status > 0);  // ON jika SEDANG atau MENYALA
    
    // Tambahkan semua data fuzzy ke response untuk Firebase
    doc["fuzzy_defuzzification"]["mu_temp_low"] = fuzzyResult.mu_temp_low;
    doc["fuzzy_defuzzification"]["mu_temp_normal"] = fuzzyResult.mu_temp_normal;
    doc["fuzzy_defuzzification"]["mu_temp_high"] = fuzzyResult.mu_temp_high;
    doc["fuzzy_defuzzification"]["mu_hum_low"] = fuzzyResult.mu_hum_low;
    doc["fuzzy_defuzzification"]["mu_hum_normal"] = fuzzyResult.mu_hum_normal;
    doc["fuzzy_defuzzification"]["mu_hum_high"] = fuzzyResult.mu_hum_high;
    doc["fuzzy_defuzzification"]["out_off"] = fuzzyResult.out_off;
    doc["fuzzy_defuzzification"]["out_medium"] = fuzzyResult.out_medium;
    doc["fuzzy_defuzzification"]["out_high"] = fuzzyResult.out_high;
    doc["fuzzy_defuzzification"]["crisp_output"] = fuzzyResult.crisp_output;
    doc["fuzzy_defuzzification"]["exhaust_status"] = fuzzyResult.exhaust_status;
    
    Serial.printf("[AUTO-FUZZY] Node %d: Temp=%.1f°C, Hum=%.1f%% -> Exhaust=%d\n", 
                  node_id, temp, hum, fuzzyResult.exhaust_status);
  }
  
  // Kirim ke Firebase
  bool firebaseSuccess = sendToFirebase(node_id, doc);
  
  // Prepare response
  DynamicJsonDocument response(512);
  response["status"] = "success";
  response["firebase"] = firebaseSuccess ? "success" : "failed";
  response["mode"] = ctrl.manual_mode ? "MANUAL" : "AUTO";
  response["actuator_command"] = ctrl.actuator_command;
  response["setpoint"] = ctrl.setpoint;
  response["timestamp"] = ctrl.timestamp;
  
  // Untuk Node Type 1, kirim fuzzy data jika auto
  if (doc.containsKey("temperature") && doc.containsKey("humidity") && !ctrl.manual_mode) {
    if (doc.containsKey("fuzzy_defuzzification")) {
      response["fuzzy_exhaust_status"] = doc["fuzzy_defuzzification"]["exhaust_status"];
    }
  }
  
  String responseStr;
  serializeJson(response, responseStr);
  server.send(200, "application/json", responseStr);
  
  if (doc.containsKey("temperature")) {
    Serial.printf("✓ Node %d (DHT): Temp=%.1f°C, Hum=%.1f%%, Mode=%s, Firebase=%s\n", 
                  node_id,
                  doc["temperature"].as<float>(),
                  doc["humidity"].as<float>(),
                  ctrl.manual_mode ? "MANUAL" : "AUTO-FUZZY",
                  firebaseSuccess ? "✓" : "✗");
  } else if (doc.containsKey("ppm")) {
    Serial.printf("✓ Node %d (TDS): PPM=%.1f, pH=%.2f, Mode=%s, Firebase=%s\n", 
                  node_id,
                  doc["ppm"].as<float>(),
                  doc["ph"].as<float>(),
                  doc["mode"].as<String>().c_str(),
                  firebaseSuccess ? "✓" : "✗");
  }
  
  Serial.println("===============================\n");
}

// Control endpoint (dari Web Dashboard)
void handleControl() {
  setCORSHeaders();
  
  if (server.method() != HTTP_POST) {
    server.send(405, "application/json", "{\"error\":\"Method not allowed\"}");
    return;
  }
  
  String body = server.arg("plain");
  DynamicJsonDocument doc(512);
  
  if (deserializeJson(doc, body)) {
    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
    return;
  }
  
  int node_id = doc["node_id"];
  
  if (node_id < 1 || node_id > NUM_NODES) {
    server.send(400, "application/json", "{\"error\":\"Invalid node_id\"}");
    return;
  }
  
  int idx = node_id - 1;
  
  if (doc.containsKey("manual_mode")) controls[idx].manual_mode = doc["manual_mode"];
  if (doc.containsKey("actuator_command")) controls[idx].actuator_command = doc["actuator_command"];
  if (doc.containsKey("setpoint")) controls[idx].setpoint = doc["setpoint"];
  
  controls[idx].timestamp = millis();
  
  // Update ke Firebase
  String path = "/nodes/node_" + String(node_id) + "/control";
  FirebaseJson json;
  json.set("manual_mode", controls[idx].manual_mode);
  json.set("actuator_command", controls[idx].actuator_command);
  json.set("setpoint", controls[idx].setpoint);
  json.set("timestamp", controls[idx].timestamp);
  
  bool firebaseSuccess = Firebase.RTDB.setJSON(&fbdo, path.c_str(), &json);
  
  DynamicJsonDocument response(256);
  response["status"] = "success";
  response["firebase"] = firebaseSuccess ? "success" : "failed";
  response["node_id"] = node_id;
  
  String responseStr;
  serializeJson(response, responseStr);
  server.send(200, "application/json", responseStr);
  
  Serial.printf("[CONTROL] Node %d: Mode=%s, Command=%s, Setpoint=%.1f, Firebase=%s\n",
                node_id,
                controls[idx].manual_mode ? "MANUAL" : "AUTO",
                controls[idx].actuator_command ? "ON" : "OFF",
                controls[idx].setpoint,
                firebaseSuccess ? "✓" : "✗");
}

// Status endpoint
void handleGetStatus() {
  setCORSHeaders();
  
  DynamicJsonDocument doc(2048);
  JsonArray nodes = doc.createNestedArray("nodes");
  
  unsigned long now = millis();
  
  for (int i = 0; i < NUM_NODES; i++) {
    JsonObject node = nodes.createNestedObject();
    node["node_id"] = i + 1;
    node["online"] = (now - node_status[i].last_seen < 30000);
    node["last_seen_sec"] = (now - node_status[i].last_seen) / 1000;
    node["node_type"] = node_status[i].node_type;
    
    if (node_status[i].node_type == 1) {
      node["temperature"] = node_status[i].temperature;
      node["humidity"] = node_status[i].humidity;
      node["exhaust_status"] = node_status[i].exhaust_status;
    } else if (node_status[i].node_type == 2) {
      node["current_ppm"] = node_status[i].current_ppm;
      node["current_ph"] = node_status[i].current_ph;
      node["pump_active"] = node_status[i].pump_active;
    }
    
    node["mode"] = node_status[i].mode;
    node["manual_mode"] = controls[i].manual_mode;
    node["actuator_command"] = controls[i].actuator_command;
    node["setpoint"] = controls[i].setpoint;
  }
  
  doc["gateway_ip"] = WiFi.localIP().toString();
  doc["uptime"] = millis() / 1000;
  doc["firebase_connected"] = firebaseReady;
  doc["firebase_stream"] = streamReady;
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n\n");
  Serial.println("╔════════════════════════════════════════╗");
  Serial.println("║  ESP32 GREENHOUSE GATEWAY + FUZZY     ║");
  Serial.println("╚════════════════════════════════════════╝\n");
  
  // Initialize arrays
  for (int i = 0; i < NUM_NODES; i++) {
    controls[i] = {false, false, 800.0f, 0};  // default setpoint 800 ppm
    node_status[i] = {0, false, 0, 0.0f, 0.0f, 0, 0.0f, 0.0f, false, "AUTO"};
  }
  
  // WiFi Connection
  Serial.println("Connecting to WiFi...");
  Serial.printf("SSID: %s\n", ssid);
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  WiFi.setAutoReconnect(true);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✅✅✅ WIFI CONNECTED! ✅✅✅\n");
    
    Serial.println("╔════════════════════════════════════════╗");
    Serial.println("║     ⚠️  GATEWAY IP ADDRESS ⚠️          ║");
    Serial.println("╠════════════════════════════════════════╣");
    Serial.print("║        ");
    Serial.print(WiFi.localIP());
    Serial.println("               ║");
    Serial.println("╠════════════════════════════════════════╣");
    Serial.println("║  UPDATE IP DI CODE NODE!               ║");
    Serial.print("║  const char* gatewayIP = \"");
    Serial.print(WiFi.localIP());
    Serial.println("\";  ║");
    Serial.println("╚════════════════════════════════════════╝\n");
    
  } else {
    Serial.println("\n❌ WIFI FAILED!\n");
    return;
  }
  
  // Firebase Configuration
  Serial.println("╔════════════════════════════════════════╗");
  Serial.println("║  CONNECTING TO FIREBASE...             ║");
  Serial.println("╚════════════════════════════════════════╝");
  
  config.database_url = FIREBASE_HOST;
  config.signer.tokens.legacy_token = FIREBASE_AUTH;
  config.timeout.serverResponse = 10 * 1000;
  
  // ✅ FIX SSL ERROR: Disable SSL verification
  config.cert.data = NULL;
  config.cert.file = "";
  config.cert.file_storage = mem_storage_type_flash;
  
  // ✅ Increase buffer size
  fbdo.setBSSLBufferSize(4096, 1024);
  fbdo_stream.setBSSLBufferSize(4096, 1024);
  
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  delay(1000);
  
  if (Firebase.ready()) {
    firebaseReady = true;
    Serial.println("\n✅✅✅ FIREBASE CONNECTED! ✅✅✅\n");
    
    syncControlFromFirebase();
    setupFirebaseStream();
    
  } else {
    Serial.println("\n❌ FIREBASE CONNECTION FAILED!\n");
    firebaseReady = false;
  }
  
  // Setup HTTP Server
  Serial.println("\n╔════════════════════════════════════════╗");
  Serial.println("║  SETTING UP HTTP SERVER...             ║");
  Serial.println("╚════════════════════════════════════════╝\n");
  
  server.on("/ping", HTTP_GET, handlePing);
  server.on("/ping", HTTP_OPTIONS, handleOptions);
  
  server.on("/api/node/sync", HTTP_POST, handleNodeSync);
  server.on("/api/node/sync", HTTP_OPTIONS, handleOptions);
  
  server.on("/api/control", HTTP_POST, handleControl);
  server.on("/api/control", HTTP_OPTIONS, handleOptions);
  
  server.on("/api/status", HTTP_GET, handleGetStatus);
  server.on("/api/status", HTTP_OPTIONS, handleOptions);
  
  server.onNotFound([]() {
    setCORSHeaders();
    server.send(404, "application/json", "{\"error\":\"Not found\"}");
  });
  
  server.begin();
  
  Serial.println("\n✅✅✅ SERVER STARTED! ✅✅✅");
  Serial.printf("Gateway ready at http://%s:8080\n", WiFi.localIP().toString().c_str());
  Serial.println("\nEndpoints:");
  Serial.println("  GET  /ping");
  Serial.println("  POST /api/node/sync");
  Serial.println("  POST /api/control");
  Serial.println("  GET  /api/status\n");
}  // ✅ PENUTUP FUNGSI SETUP

// ==================== LOOP ====================
void loop() {
  server.handleClient();
  
  // Cek Firebase stream
  if (firebaseReady && streamReady) {
    Firebase.RTDB.readStream(&fbdo_stream);
  }
  
  // Reconnect stream jika timeout
  if (firebaseReady && !streamReady && millis() - lastStreamCheck > 30000) {
    lastStreamCheck = millis();
    setupFirebaseStream();
  }
  
  delay(10);
}
